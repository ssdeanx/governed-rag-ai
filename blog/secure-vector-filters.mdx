---
title: "Deep Dive: Security-Filtered Vector Retrieval"
date: 2025-09-25T13:00:00.000Z
excerpt: "Implementing classification and role-aware predicates directly inside vector similarity search for true zero-trust RAG."
tags: [retrieval, security, design]
author: "Security Engineering"
---

Vector search without *pre-query* security constraints is an exfiltration bug waiting to ship. In this post we outline a pattern for binding **who** and **what** to **which** vectors are even *eligible* for semantic expansion.

## The Problem

Post-filtering results after an unrestricted similarity search leaks:

- Embedding distribution timing
- Score ordering patterns
- Potentially partial payloads in logs

## The Pattern

1. Derive claim envelope (roles, departments, clearance)
2. Map to classification + departmental filter sets
3. Construct filter object for the vector DB
4. Execute constrained similarity query
5. Rerank within already-authorized subset

## Pseudocode

```ts
const envelope = buildEnvelope(jwtClaims);
const filter = {
  must: [
    { key: 'classification', match: { any: envelope.classifications } },
    { key: 'department', match: { any: envelope.departments } },
  ]
};
const results = await qdrant.query({ vector, filter, top: 8 });
```

## Metadata Hygiene

Store only what you must:

- `classification`
- `department`
- `doc_id`
- Minimal `chunk_index`

Avoid embedding raw user PII, internal ticket IDs, or customer account numbers.

## Auditing Hook

Attach a structured log envelope:

```json
{
  "event": "vector.secure_query",
  "user": "finance.viewer",
  "classification_scope": ["public","internal"],
  "topk": 8,
  "duration_ms": 42
}
```

## Key Takeaway

Security belongs *inside* the retrieval operator, not bolted on after.

â€” Security Engineering
